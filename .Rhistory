mwu_fion %>% unnest_tokens(bigram_LangTag, Lang_Tags, token = "ngrams", n = 2, drop = FALSE) %>% select(bigram_LangTag))
bigrams_silvie <- bind_cols(bigrams_silvie,
mwu_silvie %>% unnest_tokens(bigram_LangTag, Lang_Tags, token = "ngrams", n = 2, drop = FALSE) %>% select(bigram_LangTag))
# one column for each word
bigrams_fion <- bigrams_fion %>% separate(bigram, c("word1", "word2"), sep = " ", remove = F)
bigrams_silvie <- bigrams_silvie %>% separate(bigram, c("word1", "word2"), sep = " ", remove = F)
bigrams_fion <- bigrams_fion %>% separate(bigram_LangTag, c("LangTag1", "LangTag2"), sep = " ", remove = F)
bigrams_silvie <- bigrams_silvie %>% separate(bigram_LangTag, c("LangTag1", "LangTag2"), sep = " ", remove = F)
# add child column
bigrams_fion <- mutate(bigrams_fion, Child = "Fion")
bigrams_silvie <- mutate(bigrams_silvie, Child = "Silvie")
# Chunk 8
# get bigrams --------------------------------------------------
bigrams_cds_fion <- fion_cds %>% unnest_tokens(bigram, Utterance_clean, token = "ngrams", n = 2)
bigrams_cds_silvie <- silvie_cds %>% unnest_tokens(bigram, Utterance_clean, token = "ngrams", n = 2)
# one column for each word
bigrams_cds_fion <- bigrams_cds_fion %>% separate(bigram, c("word1", "word2"), sep = " ", remove = F)
bigrams_cds_silvie <- bigrams_cds_silvie %>% separate(bigram, c("word1", "word2"), sep = " ", remove = F)
# Chunk 9
get_transition_probabilities <- function(df_bigrams, input_column = "Utterance_clean", age_range = "all", Speaker = "all") {
# filter
if(any(age_range!="all")) {
#df_orig <- filter(df_orig, age_range %in% age_range)
df_bigrams <- filter(df_bigrams, age_range %in% age_range)
}
if(any(Speaker!="all")) {
#df_orig <- filter(df_orig, Speaker %in% Speaker)
df_bigrams <- filter(df_bigrams, Speaker %in% Speaker)
}
# unigrams
unigrams <- df_bigrams %>% select(Utt_no, all_of(input_column)) %>% unique() %>% unnest_tokens(output = "unigram", input = input_column, token = "ngrams", n = 1)
# unigrams <- df_orig %>% unnest_tokens(output = "unigram", input = input_column, token = "ngrams", n = 1)
unigrams_tbl <- unigrams$unigram %>% table() %>% as.data.frame() %>% setNames(c("unigram", "Freq"))
# count co-occurrence frequencies of bigrams:
# first grouped by Utterance number so that
# the bigrams do not cross utterance boundaries,
# then summing up across utterances.
bigrams_df_tbl <- df_bigrams %>% group_by(Utt_no, word1, word2) %>% summarise(
n = n()
) %>% na.omit() %>% group_by(word1, word2) %>%
summarise(
n = sum(n)
)
# add unigram frequencies
bigrams_df_tbl <- left_join(bigrams_df_tbl, unigrams_tbl, by = c("word1" = "unigram")) %>% setNames(c("word1", "word2", "n", "n_word1"))
bigrams_df_tbl <- left_join(bigrams_df_tbl, unigrams_tbl, by = c("word2" = "unigram")) %>% setNames(c("word1", "word2", "n", "n_word1", "n_word2"))
# add backward and forward transitional probabilities
bigrams_df_tbl <- bigrams_df_tbl %>% mutate(ftp = n / n_word1,
btp = n / n_word2)
# return
return(bigrams_df_tbl)
}
# Chunk 10
# number of words
d_fion %>% group_by(Month) %>% summarise(
n_words = n(),
n_files = length(unique(Filename))
) %>% ggplot(aes(x=Month, y = n_words, label = n_files)) +
geom_point() +
geom_line(group = 1) +
geom_text(position = position_stack(), vjust = -0.4) +
theme(axis.text.x = element_text(angle=45, hjust=.9, size=12)) +
ylab("Number of words") +
ggtitle("Fion (numbers indicate number of transcripts)") + d_silvie %>% group_by(Month) %>% summarise(
n_words = n(),
n_files = length(unique(Filename))
) %>% ggplot(aes(x=Month, y = n_words, label = n_files)) +
geom_point() +
geom_line(group = 1) +
geom_text(position = position_stack(), vjust = -0.4) +
theme(axis.text.x = element_text(angle=45, hjust=.9, size=12)) +
ylab("Number of words") +
ggtitle("Silvie (numbers indicate number of transcripts)")
# Chunk 11
# function for getting equal-sized intervals
get_equal_bins <- function(x, n) {
cur_var <- 1:length(unique(x))
cur_breaks <- round(seq(1, length(unique(x)), by = length(unique(x)) / n))
# add last number to breaks
cur_breaks[length(cur_breaks)+1] <- cur_var[length(cur_var)]
# add 0 to var and breaks so that we can calculate +1
# below to avoid overlaps between two groups
cur_var <- c(0, cur_var)
cur_breaks[1] <- 0
# cur_breaks[1] <- 0 # to make sure that it starts with 1
cur_list <- lapply(1:(length(cur_breaks)-1), function(i) cur_var[((which(cur_var==cur_breaks[i])+1)):(which(cur_var==cur_breaks[1+i]))])
return(cur_list)
}
# function for adding months column
add_month_bins <- function(df, n_bins) {
cur_bins <- get_equal_bins(df$Month, n_bins)
# list to dataframe
cur_bins_df <- do.call(rbind, lapply(1:length(cur_bins), function(i) tibble(index = i,
no    = cur_bins[[i]])))
# get bin range
bins_tbl01 <- tibble(age = unique(df$Month),
no = 1:length(unique(df$Month)))
# join
cur_bins_df <- left_join(cur_bins_df, bins_tbl01)
# bins in character form (from a to b)
cur_bins_ch <- sapply(1:length(cur_bins), function(i) paste0(unique(df$Month)[cur_bins[[i]][1]], "-",
unique(df$Month)[cur_bins[[i]][length(cur_bins[[i]])]]))
# in tabular form
bins_tbl <- tibble(bin = 1:length(cur_bins),
age_range = cur_bins_ch)
# add to existing dataframe
cur_bins_df <- left_join(cur_bins_df, bins_tbl, by = c("index" = "bin"))
# return Months column
cur_df_with_age_range <- left_join(df, select(cur_bins_df, age, age_range), by = c("Month" = "age"))
return(cur_df_with_age_range)
}
# Chunk 12
# count:
# first grouped by Utterance number so that
# the bigrams do not cross utterance boundaries,
# then summing up across utterances.
bigrams_fion_cds_count <- bigrams_cds_fion %>% group_by(Utt_no, word1, word2, lang) %>% summarise(
n = n()
) %>% na.omit() %>% group_by(word1, word2, lang) %>%
summarise(
n = sum(n)
) %>% arrange(desc(n))
bigrams_silvie_cds_count <- bigrams_cds_silvie %>% group_by(Utt_no, word1, word2, lang) %>% summarise(
n = n()
) %>% na.omit() %>% group_by(word1, word2, lang) %>%
summarise(
n = sum(n)
) %>% arrange(desc(n))
# add language tag to the words
bigrams_fion_cds_count$word1 <- paste0(bigrams_fion_cds_count$word1, "_", bigrams_fion_cds_count$lang)
bigrams_fion_cds_count$word2 <-paste0(bigrams_fion_cds_count$word2, "_", bigrams_fion_cds_count$lang)
# Chunk 13
# how many months for Fion and Silvie?
length(unique(d_fion$Month))
length(unique(d_silvie$Month))
# add bins
bigrams_fion <- bigrams_fion %>% add_month_bins(n_bins = 7)
bigrams_silvie <- bigrams_silvie %>% add_month_bins(n_bins = 6)
d_fion <- d_fion %>% add_month_bins(n_bins = 7)
d_silvie <- d_silvie %>% add_month_bins(n_bins = 6)
# Chunk 14
# Get bins
bigrams_cds_fion <- bigrams_cds_fion %>% add_month_bins(n = 3)
bigrams_cds_silvie <- bigrams_cds_silvie %>% add_month_bins(n = 3)
fion_cds <- fion_cds %>% add_month_bins(n = 3)
silvie_cds <- silvie_cds %>% add_month_bins(n = 3)
# Chunk 15
# get samples
# Fion:
for(i in 1:7) {
cur_fion <- filter(bigrams_fion, age_range == levels(factor(bigrams_fion$age_range))[i])
set.seed(i)
cur_samples <- lapply(1:100, function(i) sample(1:length(unique(cur_fion$Utt_no)), 450))
assign(paste0("bigrams_fion0", i), cur_fion[unlist(cur_samples),])
}
# Silvie:
for(i in 1:6) {
cur_silvie <- filter(bigrams_silvie, age_range == levels(factor(bigrams_silvie$age_range))[i])
set.seed(i)
cur_samples <- lapply(1:100, function(i) sample(1:length(unique(cur_silvie$Utt_no)), 450))
assign(paste0("bigrams_silvie0", i), cur_silvie[unlist(cur_samples),])
}
# Chunk 16
# get 25,000-utterance samples for each of the bins
set.seed(12345)
for(i in 1:3) {
cur_bigrams <- bigrams_cds_fion %>% filter(age_range == levels(factor(bigrams_cds_fion$age_range))[i])
cur_spl <- sample(1:nrow(cur_bigrams), 45000)
assign(paste0("bigrams_cds_fion0", i), cur_bigrams[cur_spl,])
}
set.seed(12345)
for(i in 1:3) {
cur_bigrams <- bigrams_cds_silvie %>% filter(age_range == levels(factor(bigrams_cds_silvie$age_range))[i])
cur_spl <- sample(1:nrow(cur_bigrams), 45000)
assign(paste0("bigrams_cds_silvie0", i), cur_bigrams[cur_spl,])
}
get_network <- function(bigram_df,n_min = 0, modularity_measure = FALSE, edges = "ftp") {
# count the bigram_df
bigrams_count <- bigram_df %>% group_by(LangTag1, LangTag2) %>% count(word1, word2, sort = T)
# filter out all below n_min
l <- bigrams_count %>%
filter(n >= n_min)
# add transitional probabilities
l1 <- left_join(l, select(get_transition_probabilities(bigram_df, input_column = "Utterance_clean"), -n), by = c("word1", "word2") )
# check if there are data
if(nrow(l1) > 0) {
# get bigram graph edges and vertices
bigram_graph <- l1 %>%
filter(n >= n_min) %>%
ungroup %>% select(word1, word2, all_of(edges)) %>% graph_from_data_frame(directed = FALSE)
# set weight attributes
if(edges == "ftp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$ftp)
} else if(edges=="btp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$btp)
} else if(edges=="n") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$n)
}
# set labels
V(bigram_graph)$label <- V(bigram_graph)$name
# Louvain clustering
lv <- cluster_louvain(bigram_graph)
# add Louvain clustering to graph
V(bigram_graph)$community <- membership(lv)
# add language and word frequency as attributes
# to do so, we need a list of unigrams
# language tags of unigrams
unigram_LangTags <-  bind_cols(bigram_df %>% select(Utt_no, Utterance_clean, Lang_Tags) %>% unique() %>% unnest_tokens(output = "unigram", input = "Utterance_clean", token = "ngrams", n = 1),
select(bigram_df %>% select(Utt_no, Utterance_clean, Lang_Tags) %>% unique() %>% unnest_tokens(output = "unigram_LangTag", input = Lang_Tags, token = "ngrams", n = 1), unigram_LangTag)) %>% select(unigram, unigram_LangTag) %>% unique()
# get frequencies of individual words
unigrams_freqs <- bigram_df %>% select(Utt_no, Utterance_clean) %>% unique() %>% unnest_tokens(output = "unigram", input = Utterance_clean) %>% group_by(unigram) %>% summarise(
n = n()
)
# add unigram LangTags as attributes to the graph
V(bigram_graph)$language <- sapply(1:length(V(bigram_graph)), function(i) unigram_LangTags[which(unigram_LangTags$unigram == V(bigram_graph)$name[i]),]$unigram_LangTag[1])
# add color as attribute
V(bigram_graph)$color <- case_when(V(bigram_graph)$language == "g" ~ "salmon",
V(bigram_graph)$language == "e" ~ "deepskyblue",
V(bigram_graph)$language == "eg" ~ "tan",
.default = "grey")
# add frequency as attribute
V(bigram_graph)$Freq <- sapply(1:length(V(bigram_graph)), function(i) unigrams_freqs[which(unigrams_freqs$unigram==V(bigram_graph)$name[i]),]$n[1])
# return graph or modularity measure
if(modularity_measure) {
return(modularity(lv))
} else {
return(bigram_graph)
}
}
}
# add missing columns
bigrams_cds_fion$LangTag1 <- bigrams_cds_fion$lang
bigrams_cds_fion$LangTag2 <- bigrams_cds_fion$lang
bigrams_cds_fion$Lang_Tags <- bigrams_cds_fion$lang
bigrams_cds_fion$Utterance_clean <- bigrams_cds_fion$Utterance
bigrams_cds_silvie$LangTag1 <- bigrams_cds_silvie$lang
bigrams_cds_silvie$LangTag2 <- bigrams_cds_silvie$lang
bigrams_cds_silvie$Lang_Tags <- bigrams_cds_silvie$lang
bigrams_cds_silvie$Utterance_clean <- bigrams_cds_silvie$Utterance
# function for getting CDS networks
get_network_cds <- function(bigram_df, n_min = 0, modularity_measure = FALSE, edges = "ftp") {
bigrams_count <- bigram_df %>% group_by(LangTag1, LangTag2) %>% count(word1, word2, sort = T)
# bigrams_count <- na.omit(bigrams_count)
# filter out all below n_min
l <- bigrams_count %>%
filter(n >= n_min)
# add transitional probabilities
l1 <- left_join(l, select(get_transition_probabilities(bigram_df, input_column = "Utterance_clean"), -n), by = c("word1", "word2") )
# omit NAs (usually blank spaces)
l1 <- na.omit(l1)
# check if there are data
if(nrow(l1) > 0) {
# get bigram graph edges and vertices
bigram_graph <- l1 %>%
filter(n >= n_min) %>%
ungroup %>% select(word1, word2, all_of(edges)) %>% graph_from_data_frame(directed = FALSE)
# set weight attributes
if(edges == "ftp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$ftp)
} else if (edges == "btp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$btp)
} else if(edges == "n") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$n)
}
# set labels
V(bigram_graph)$label <- V(bigram_graph)$name
# Louvain clustering
lv <- cluster_louvain(bigram_graph)
# add Louvain clustering to graph
V(bigram_graph)$community <- membership(lv)
# add language and word frequency as attributes
# to do so, we need a list of unigrams
# language tags of unigrams
lang_tbl <- unique(select(bigram_df, word1, word2, lang)) %>% pivot_longer(cols = 1:2) %>% select(value, lang) %>% setNames(c("word", "language")) %>% unique()
# add language tags to network
V(bigram_graph)$language <-  sapply(1:length(V(bigram_graph)$name), function(i) lang_tbl[which(lang_tbl$word == V(bigram_graph)$name[i])[1],]$language)
# get frequencies of individual words
unigrams_freqs <- bigram_df %>% select(Utt_no, Utterance) %>% unique() %>% unnest_tokens(output = "unigram", input = Utterance) %>% group_by(unigram) %>% summarise(
n = n()
)
# add color as attribute
V(bigram_graph)$color <- case_when(V(bigram_graph)$language == "de" ~ "salmon",
V(bigram_graph)$language == "en" ~ "deepskyblue",
V(bigram_graph)$language == "mixed" ~ "tan",
.default = "grey")
# add frequency as attribute
V(bigram_graph)$Freq <- sapply(1:length(V(bigram_graph)), function(i) unigrams_freqs[which(unigrams_freqs$unigram==V(bigram_graph)$name[i]),]$n[1])
}
# return graph or modularity measure
if(modularity_measure) {
return(modularity(lv))
} else {
return(bigram_graph)
}
}
# add missing columns
bigrams_cds_fion$LangTag1 <- bigrams_cds_fion$lang
bigrams_cds_fion$LangTag2 <- bigrams_cds_fion$lang
bigrams_cds_fion$Lang_Tags <- bigrams_cds_fion$lang
bigrams_cds_fion$Utterance_clean <- bigrams_cds_fion$Utterance
bigrams_cds_fion01$LangTag1 <- bigrams_cds_fion01$lang
bigrams_cds_fion01$LangTag2 <- bigrams_cds_fion01$lang
bigrams_cds_fion01$Lang_Tags <- bigrams_cds_fion01$lang
bigrams_cds_fion01$Utterance_clean <- bigrams_cds_fion01$Utterance
bigrams_cds_silvie01$LangTag1 <- bigrams_cds_silvie01$lang
bigrams_cds_silvie01$LangTag2 <- bigrams_cds_silvie01$lang
bigrams_cds_silvie01$Lang_Tags <- bigrams_cds_silvie01$lang
bigrams_cds_silvie01$Utterance_clean <- bigrams_cds_silvie01$Utterance
bigrams_cds_fion02$LangTag1 <- bigrams_cds_fion02$lang
bigrams_cds_fion02$LangTag2 <- bigrams_cds_fion02$lang
bigrams_cds_fion02$Lang_Tags <- bigrams_cds_fion02$lang
bigrams_cds_fion02$Utterance_clean <- bigrams_cds_fion02$Utterance
bigrams_cds_silvie02$LangTag1 <- bigrams_cds_silvie02$lang
bigrams_cds_silvie02$LangTag2 <- bigrams_cds_silvie02$lang
bigrams_cds_silvie02$Lang_Tags <- bigrams_cds_silvie02$lang
bigrams_cds_silvie02$Utterance_clean <- bigrams_cds_silvie02$Utterance
bigrams_cds_fion03$LangTag1 <- bigrams_cds_fion03$lang
bigrams_cds_fion03$LangTag2 <- bigrams_cds_fion03$lang
bigrams_cds_fion03$Lang_Tags <- bigrams_cds_fion03$lang
bigrams_cds_fion03$Utterance_clean <- bigrams_cds_fion03$Utterance
bigrams_cds_silvie03$LangTag1 <- bigrams_cds_silvie03$lang
bigrams_cds_silvie03$LangTag2 <- bigrams_cds_silvie03$lang
bigrams_cds_silvie03$Lang_Tags <- bigrams_cds_silvie03$lang
bigrams_cds_silvie03$Utterance_clean <- bigrams_cds_silvie03$Utterance
# function for getting CDS networks
get_network_cds <- function(bigram_df, n_min = 0, modularity_measure = FALSE, edges = "ftp") {
bigrams_count <- bigram_df %>% group_by(LangTag1, LangTag2) %>% count(word1, word2, sort = T)
# bigrams_count <- na.omit(bigrams_count)
# filter out all below n_min
l <- bigrams_count %>%
filter(n >= n_min)
# add transitional probabilities
l1 <- left_join(l, select(get_transition_probabilities(bigram_df, input_column = "Utterance_clean"), -n), by = c("word1", "word2") )
# omit NAs (usually blank spaces)
l1 <- na.omit(l1)
# check if there are data
if(nrow(l1) > 0) {
# get bigram graph edges and vertices
bigram_graph <- l1 %>%
filter(n >= n_min) %>%
ungroup %>% select(word1, word2, all_of(edges)) %>% graph_from_data_frame(directed = FALSE)
# set weight attributes
if(edges == "ftp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$ftp)
} else if (edges == "btp") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$btp)
} else if(edges == "n") {
bigram_graph <- set_edge_attr(bigram_graph, "weight", value = l1$n)
}
# set labels
V(bigram_graph)$label <- V(bigram_graph)$name
# Louvain clustering
lv <- cluster_louvain(bigram_graph)
# add Louvain clustering to graph
V(bigram_graph)$community <- membership(lv)
# add language and word frequency as attributes
# to do so, we need a list of unigrams
# language tags of unigrams
lang_tbl <- unique(select(bigram_df, word1, word2, lang)) %>% pivot_longer(cols = 1:2) %>% select(value, lang) %>% setNames(c("word", "language")) %>% unique()
# add language tags to network
V(bigram_graph)$language <-  sapply(1:length(V(bigram_graph)$name), function(i) lang_tbl[which(lang_tbl$word == V(bigram_graph)$name[i])[1],]$language)
# get frequencies of individual words
unigrams_freqs <- bigram_df %>% select(Utt_no, Utterance) %>% unique() %>% unnest_tokens(output = "unigram", input = Utterance) %>% group_by(unigram) %>% summarise(
n = n()
)
# add color as attribute
V(bigram_graph)$color <- case_when(V(bigram_graph)$language == "de" ~ "salmon",
V(bigram_graph)$language == "en" ~ "deepskyblue",
V(bigram_graph)$language == "mixed" ~ "tan",
.default = "grey")
# add frequency as attribute
V(bigram_graph)$Freq <- sapply(1:length(V(bigram_graph)), function(i) unigrams_freqs[which(unigrams_freqs$unigram==V(bigram_graph)$name[i]),]$n[1])
}
# return graph or modularity measure
if(modularity_measure) {
return(modularity(lv))
} else {
return(bigram_graph)
}
}
# function for plotting
get_plot <- function(cur_network, myseed = 1999, min_freq = 0, interactive = FALSE, repel = TRUE, max.overlaps = 20, communities = "all", input = "igraph") {
if(input == "layout") {
layout <- cur_network
} else {
# get plot layout
layout <- create_layout(cur_network, layout = "fr")
}
# allow for selecting individual communities
if(any(communities != "all")) {
layout <- filter(layout, community %in% communities)
}
# Build plot
set.seed(myseed)
p <- ggplot(layout) +
geom_edge_link(aes(x = x, y = y, xend = xend, yend = yend,
edge_width = weight, alpha = weight), color = "gray") +
scale_edge_width(range = c(0.1, 0.5)) +
geom_point_interactive(
aes(x = x, y = y, tooltip = name, color = color, size = Freq)
) +
geom_node_text(aes(label = ifelse(Freq > min_freq, name, ""), size = Freq), repel = repel, max.overlaps = max.overlaps) +
stat_ellipse(aes(x=x, y=y, group = as.factor(community), fill = as.factor(community)),
geom = "polygon", alpha = 0.1, color = NA) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")
if(interactive) {
# Zoomable plot with girafe
g <- girafe(
ggobj = p,
options = list(
opts_zoom(min = 1, max = 60),
opts_toolbar(saveaspng = TRUE)
)
)
return(g)
} else {
return(p)
}
}
# create seven plot objects named p_f1 to p_f7 for Fion's networks
for(i in 1:7) {
assign(paste0("p_f", i), get(paste0("bigrams_fion0", i)) %>% get_network() %>% get_plot(repel = TRUE, max.overlaps = 50, min_freq = 5) + ggtitle(levels(factor(bigrams_fion$age_range))[i]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)))
}
(p_f1 | p_f2 | p_f3) /
(p_f4 | p_f5 | p_f6) /
p_f7 + plot_annotation("Bigram network, Fion", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
for(i in 1:7) {
cur_network <- get_network(get(paste0("bigrams_fion0", i)), edges = "n")
largest_communities <- cur_network %>% create_layout(layout = "fr") %>% group_by(community) %>% summarise(
n = n()
) %>% arrange(desc(n)) %>% head(3) %>% select(community) %>% as.vector() %>% unname() %>% unlist()
assign(paste0("p_lc_f", i), cur_network %>% get_plot(communities = largest_communities) + ggtitle(levels(factor(bigrams_fion$age_range[i]))) + theme(plot.title = element_text(face = "bold", hjust = 0.5)))
}
p_lc_f1 + p_lc_f4 + p_lc_f7 + plot_annotation(title = "Largest clusters, Fion", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
# create six plot objects named p_f1 to p_f7 for Silvie's networks
for(i in 1:6) {
assign(paste0("p_s", i), get(paste0("bigrams_silvie0", i)) %>% get_network() %>% get_plot(repel = TRUE, min_freq = 5, max.overlaps = 50) + ggtitle(levels(factor(bigrams_silvie$age_range))[i]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)))
}
(p_s1 | p_s2 | p_s3) /
(p_s4 | p_s5 | p_s6) + plot_annotation("Bigram network, Silvie", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
# get largest communities
for(i in 1:6) {
cur_network <- get_network(get(paste0("bigrams_silvie0", i)))
largest_communities <- cur_network %>% create_layout(layout = "fr") %>% group_by(community) %>% summarise(
n = n()
) %>% arrange(desc(n)) %>% head(3) %>% select(community) %>% as.vector() %>% unname() %>% unlist()
assign(paste0("p_lc_s", i), cur_network %>% get_plot(communities = largest_communities) + ggtitle(levels(factor(bigrams_silvie$age_range[i]))) + theme(plot.title = element_text(face = "bold", hjust = 0.5)))
}
p_lc_s1 + p_lc_s3 + p_lc_s6 + plot_annotation(title = "Largest clusters, Silvie", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
silvie_MOT01 <- bigrams_cds_silvie01 %>% filter(Speaker == "MOT") %>% get_network_cds()
silvie_FAT01 <- bigrams_cds_silvie01 %>% filter(Speaker == "MOT") %>% get_network_cds()
cur_network <- silvie_MOT01 %>% create_layout(layout = "fr")
largest_communities <- cur_network %>% group_by(community) %>% summarise(
n = n()
) %>% arrange(desc(n)) %>% head(3) %>% select(community) %>% as.vector() %>% unname() %>% unlist()
cur_network %>% get_plot(communities = largest_communities)
silvie_MOT01 <- bigrams_cds_silvie01 %>% filter(Speaker == "MOT") %>% get_network_cds(n_min = 5)
silvie_MOT02 <- bigrams_cds_silvie02 %>% filter(Speaker == "MOT") %>% get_network_cds(n_min = 5)
silvie_MOT03 <- bigrams_cds_silvie03 %>% filter(Speaker == "MOT") %>% get_network_cds(n_min = 5)
silvie_FAT01 <- bigrams_cds_silvie01 %>% filter(Speaker == "FAT") %>% get_network_cds(n_min = 5)
silvie_FAT02<- bigrams_cds_silvie02 %>% filter(Speaker == "FAT") %>% get_network_cds(n_min = 5)
silvie_FAT03 <- bigrams_cds_silvie03 %>% filter(Speaker == "FAT") %>% get_network_cds(n_min = 5)
cur_network <- silvie_MOT01 %>% create_layout(layout = "fr")
largest_communities <- cur_network %>% group_by(community) %>% summarise(
n = n()
) %>% arrange(desc(n)) %>% head(3) %>% select(community) %>% as.vector() %>% unname() %>% unlist()
cur_network %>% get_plot(communities = largest_communities)
cur_network <- silvie_FAT01 %>% create_layout(layout = "fr")
largest_communities <- cur_network %>% group_by(community) %>% summarise(
n = n()
) %>% arrange(desc(n)) %>% head(3) %>% select(community) %>% as.vector() %>% unname() %>% unlist()
cur_network %>% get_plot(communities = largest_communities)
silvie_MOT01 %>% get_plot()
cur_network <- silvie_MOT01 %>% create_layout(layout = "fr")
(silvie_MOT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_MOT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_MOT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)))
(silvie_MOT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_MOT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_MOT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))) + plot_annotation(title = "Bigram network, Silvie's mother", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
ggsave("images/silvie_MOT_networks.png", width = 15, height = 10)
(silvie_FAT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))) + plot_annotation(title = "Bigram network, Silvie's FATher", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
ggsave("images/silvie_FAT_networks.png", width = 15, height = 10)
(silvie_FAT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))) + plot_annotation(title = "Bigram network, Silvie's father", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
ggsave("images/silvie_FAT_networks.png", width = 15, height = 10)
?plot_annotation
# titles for rows
title1 <- wrap_elements(grid::textGrob("Bigram network, Silvie's mother", gp = grid::gpar(fontsize = 16, fontface = "bold")))
title2 <- wrap_elements(grid::textGrob("Bigram network, Silvie's father", gp = grid::gpar(fontsize = 16, fontface = "bold")))
p_sm1 <- silvie_MOT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
p_sm2 <- silvie_MOT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
p_sm3 <- silvie_MOT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
(p_sm1 + p_sm2 + p_sm3)
(silvie_FAT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5)) |
silvie_FAT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))) + plot_annotation(title = "Bigram network, Silvie's father", theme = theme(plot.title = element_text(size=18, hjust = 0.5, face = "bold")))
p_sf1 <- silvie_FAT01 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[1]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
p_sf2 <- silvie_FAT02 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[2]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
p_sf3 <- silvie_FAT03 %>% get_plot() + ggtitle(levels(factor(silvie_cds$age_range))[3]) + theme(plot.title = element_text(face = "bold", hjust = 0.5))
p_sf <- (p_sf1 + p_sf2 + p_sf3)
# titles for rows
p_sm_title <- wrap_elements(grid::textGrob("Bigram network, Silvie's mother", gp = grid::gpar(fontsize = 16, fontface = "bold")))
p_sf_title <- wrap_elements(grid::textGrob("Bigram network, Silvie's father", gp = grid::gpar(fontsize = 16, fontface = "bold")))
p_sm <- p_sm_title / (p_sm1 + p_sm2 + p_sm3)
p_sf <- p_sf_title / (p_sf1 + p_sf2 + p_sf3)
p_sm / p_sf
